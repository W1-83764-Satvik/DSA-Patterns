// Problem:
// Detect whether a linked list has a cycle in it using fast and slow pointers.

// Time Complexity: O(n)
// Space Complexity: O(1)

public boolean findCycle() {
        Node slow = head;
        Node fast = head;

        // Move slow by 1 step and fast by 2 steps
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            // If they meet, a cycle exists
            if (slow == fast) return true;
        }

        // If fast reaches the end, no cycle
        return false;
    }

/*
Key Takeaways for Fast Revision:
1. Use two pointers (slow and fast) to traverse the list.
2. Slow moves 1 step at a time, fast moves 2 steps.
3. If a cycle exists, fast will eventually meet slow.
4. If fast reaches null or fast.next is null, there’s no cycle.
5. This is called Floyd’s Cycle Detection Algorithm (Tortoise & Hare).
6. Time complexity is O(n), space is O(1) — very efficient.
7. You don’t need extra space like HashSet or visited flags.
8. Works well in memory-sensitive environments or constrained systems.
*/
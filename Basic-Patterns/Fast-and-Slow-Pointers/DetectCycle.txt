// Problem:
// Given a linked list, return the node where the cycle begins.
// If there is no cycle, return null.
// You must solve it without modifying the list and using O(1) space.

// Time Complexity: O(n)
// Space Complexity: O(1)


    public ListNode detectCycle(ListNode head) {
        if (head == null) return null;

        ListNode slow = head, fast = head;

        // Step 1: Detect cycle
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            // Cycle detected
            if (slow == fast) {
                // Step 2: Move one pointer to head
                slow = head;

                // Step 3: Move both one step at a time to find cycle start
                while (slow != fast) {
                    slow = slow.next;
                    fast = fast.next;
                }

                return slow; // Start node of the cycle
            }
        }

        return null; // No cycle
    }   


/*
Key Takeaways for Fast Revision:
1. Step 1: Use two pointers (slow and fast) to detect if a cycle exists (same as Floyd’s).
2. Step 2: If cycle is detected, move one pointer to head.
3. Step 3: Move both pointers one step at a time — they will meet at the starting node of the cycle.
4. Why this works:
   - Distance from head to start of cycle = Distance from meeting point to start of cycle (looped path).
5. Time complexity is O(n), and space complexity is O(1).
6. Works without modifying the original list or using extra space like HashSet.
7. This problem is a favorite in technical interviews.
*/
